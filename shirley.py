#
# Progam to compare proteins
#
"""
    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
    Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <https://www.gnu.org/licenses/>.
"""

import argparse
from Bio import Entrez
import configparser
import logging
import os
from pprint import pprint
import re
import subprocess
import sys
import time
import urllib

VERSION = "0.3.3"


#
# Function to setup a new record. This is the data structure used within
# this program for working the data
#
# Inputs
# - name (e.g. UZG29433.1)
#
# Outputs
# - new entry
#
def new_record(friendly_name: str) -> dict:

    entry = {
             # Friendly name, e.g. Wuhan-Hu-1 taken from input file
             'friendly_name': friendly_name,

             # Description, e.g. surface glycoprotein [Severe acute respir...
             # taken from www.ncbi.nlm.nih.gov protein database
             'description': "",

             # Raw sequence taken from ww.ncbi.nlm.nih.gov protein database
             'raw_sequence': "",
             'raw_len': 0,

             # Aligned sequence, output from mafft!
             'aligned_sequence': "",
             'align_len': 0,

             # Sequence, e.g. MFVFLVLLPLVSSQCV----NLITRT
             # Generated by comparison with the reference sequence,
             # using the external program mafft
             'compared_sequence': "",
             'compare_len': 0,
             'dash_count': 0,

             # Position record for output display counting
             'position': 0,

             # Receptor binding domain similatiry
             'rbd_similarity': 0,

             # Receptor binding motif similarity
             'rbm_similarity': 0,

             # Overall similarity
             'full_similarity': 0
             }

    return(entry)


#
# Function to identify the accession records to be compared.
#
# Each line of the specified file is searched for lines of the form
# <not whitespace><whitespace> followed by
# <eight or more uppercase letters, digits, underscores>.<single digit>
#
# Inputs
# - filename
#
# Outputs
# - new record in the 'data' dictionary, with name as key
#
def determine_sequences(filename: str):

    # Dictionary to temporarily hold the names
    names = {}

    # Read each line from the file specified on the command line
    with open(filename) as fh:
        for line in fh:
            # Skip commented lines
            if line[0] == "#":
                continue

            # Search for the formatted text
            m = re.match(r"([\s\S]+)\s+([A-Z0-9_]{8,}\.[0-9])", line)

            # If we find correctly formatted text and this is new
            if m:
                if m.group(2) not in data:

                    # Record it!
                    names[m.group(2)] = new_record(m.group(1))
                    out = f"Recording new '{m.group(2)}' aka "
                    out += f"'{m.group(1)}' from {filename}"
                    logging.info(out)
                else:
                    logging.warning(f"Duplicate of '{m.group(1)}' found!")

    # Check we found some names
    if len(names) == 0:
        logging.critical("No IDs found in input file")
        sys.exit(-1)
    # Check we found the reference
    elif config['reference']['name'] not in names:
        logging.critical("Reference sequence is not in the input file")
        sys.exit(-1)
    else:
        # Load our data structure, with the reference name first
        for name in names:
            if name == config['reference']['name']:
                data[name] = names[name]
        # The names were added to the dictionary in the order they appeared
        # in the input file and so that will be reflected in the sequence
        # display. Make changes here if any other order is desired
        for name in names:
            if name != config['reference']['name']:
                data[name] = names[name]


#
# Function to collect the sequences
#
# The sequence will be loaded from a local file, but if we do not have a
# local file, then the sequence will be collected from the website and
# saved to local file.
#
# Doing this reduces the load on the website and means this program can work
# when internet connectivity isn't available.
#
# If the sequences go stale (i.e. the sequence is updated on the website)
# then the user can delete the local file copies of the sequences and this
# function will then collect a new copy from the website.
#
# Inputs
# - names from 'data'
# - email address to use for Entrez comms
#
# Outputs
# - sequences in files
#
def fetch_sequences(email_address: str):

    # Handle to Entrez
    handle = None

    # Step through all the names
    for name in data:

        # Define where the page_data will be stored
        page_data = None

        # Define a filename in which to store the data
        filename = name + ".txt"

        # If the file exists,  collect data from file
        if os.path.isfile(filename):

            logging.info(f"Collecting sequence for {name} from {filename}")
            with open(filename) as fh:
                page_data = fh.read()

                # Check we have a sequence
                if not page_data or len(page_data) < 1000:
                    logging.critical("Sequence could not be collected")
                    sys.exit(-1)
        else:
            logging.info(f"Collecting sequence for {name} from Entrez")

            # If we don't have a handle, grab one!
            if not handle:
                Entrez.email = email_address
                handle = Entrez.einfo()

            # Collect and read the data
            try:
                handle = Entrez.efetch(db="protein",
                                       id=name,
                                       rettype="fasta",
                                       retmode="text")
            except urllib.error.HTTPError:
                handle = None
                logging.critical(f"Failed to collect sequence for {name}")
                logging.critical("Is this a valid accession id?")
                sys.exit(-1)

            # Do not strip!
            page_data = handle.read()

            # Check we have a sequence
            if not page_data or len(page_data) < 1000:
                logging.critical("Sequence could not be collected")
                sys.exit(-1)

            # Cache the data for future use
            with open(filename, 'w') as fh:
                fh.write(page_data)

            # Brief (1/2 second) pause to be a polite Entrez user
            time.sleep(0.5)

        # Store the sequence locally
        raw_sequence = ""

        lines = page_data.split("\n")

        for line in lines:
            if not line.startswith('>'):
                raw_sequence += line.strip()

        data[name]['raw_sequence'] = raw_sequence
        data[name]['raw_len'] = len(raw_sequence)


#
# Function to assemble the input file for the mafft program
#
# Write the reference sequence first and then all the others
#
# Inputs
# - filename to hold the sequences
#
# Outputs
# - None
#
def assemble_mafft_files(filename: str):

    # Name and open the output file
    with open(filename, "w") as fh_out:
        logging.info("Preparing mafft input file...")

        # Write the reference sequence first
        for entry in data:
            if entry == config['reference']['name']:
                infile = entry + ".txt"
                with open(infile) as fh_in:
                    fh_out.write(fh_in.read())

        # Write all the other sequences
        for entry in data:
            if entry != config['reference']['name']:
                infile = entry + ".txt"
                with open(infile) as fh_in:
                    fh_out.write(fh_in.read())


#
# Function to save the aligned sequence into the internal data structure
#
# Inputs
# - name of the sequence (accession ID)
# - description of the seuence, from teh website
# - the sequence
#
# Outputs
# - name, description, aligned_sequence and align_len in data{}
#
def save_aligned_sequence(name: str, description: str, sequence: list):

    data[name]['name'] = name
    data[name]['description'] = description

    # Replace the '-', used by mafft to indicate missing
    # sections, with '/' as that's what the customer wanted
    data[name]['aligned_sequence'] = sequence.replace("-", "/")
    data[name]['align_len'] = len(data[name]['aligned_sequence'])


#
# Function to ingest the mafft aligned sequences
#
# Inputs
# - lines read from the mafft output
#
# Outputs
# - name, description and (aligned) sequence in 'data'
#
def ingest_aligned_data(lines: list):
    # Ingest the aligned sequences

    # Places to store things
    name = ""
    description = ""
    sequence = ""

    # Each aligned sequence starts with a line beginning '>'
    for line in lines:

        # Ignore empty lines
        if len(line) > 0:

            # Find the label line
            if line[0] == '>':

                # If we have a sequence already, save it
                if name and description and sequence:
                    save_aligned_sequence(name, description, sequence)

                    # Clear entries
                    name = ""
                    description = ""
                    sequence = ""

                # extract the name and description
                m = re.match(">([^ ]+) (.*)$", line)
                if m:
                    name = m.group(1)
                    description = m.group(2)

            # If we have a name, we should be recording the sequence
            elif name:
                if not sequence:
                    sequence = line.strip()
                else:
                    sequence += line.strip()

    # Save the last sequence
    save_aligned_sequence(name, description, sequence)


#
# Function to align the sequences using MAFFT
#
# General process is:
# 1. Build a file to hold the sequences, reference sequence first
# 2. Use mafft to align the sequences
# 3. Parse the mafft output into our data structure
#
# Inputs
# - sequence names from 'data'
#
# Outputs
# - name, description and (aligned) sequence in 'data'
#
def align_sequences():

    # Assemble files
    outfile = "sequences.temp"
    assemble_mafft_files(outfile)

    # Call the mafft sequencer and snag stdout
    logging.info("Aligning sequences...")
    res = subprocess.run(["mafft", "--auto", outfile],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.STDOUT,
                         text=True)

    # Collect the raw data
    rawdata = res.stdout

    # Check for warnings
    warn = rawdata.find("Warning")

    # Print one line, or fifty characters of warning
    if warn > -1:
        end = rawdata[warn:].find("\n")

        if end == -1:
            end = 50

        logging.critical("\nBailing out due to warning from mafft:")
        logging.critical(f"\t'{rawdata[warn:warn+end]}'")
        sys.exit(-1)
    else:
        # Make a list of the lines
        lines = rawdata.split("\n")

        # Ingest the data
        ingest_aligned_data(lines)


#
# Function to build a list of offsets. If given an offset in the raw
# reference sequence, this allows you to find out what the offset is
# in the aligned sequence
#
# Inputs
# - sequence names from 'data'
#
# Outputs
# - name, description and (aligned) sequence in 'data'
#
def align_off(name: str,
              offsets: list,
              start_in: str,
              end_in: str,
              raw_sequence: list):

    # Find the aligned sequence
    aligned_sequence = data[name]['aligned_sequence']

    # start_in and end_in are both strings and are 1 based
    # Convert to zero based integers

    # Find the receptor binding domain - raw
    raw_start = int(start_in)-1
    raw_end = int(end_in)-1

    # Collect the first and last four letters for later display
    raw_start_quad = raw_sequence[raw_start:raw_start+4]
    raw_end_quad = raw_sequence[raw_end-4:raw_end]

    # Find the domain in the aligned sequence
    start = offsets[raw_start]
    end = offsets[raw_end]

    # Collect the first and last four letters for later display
    ali_start_quad = aligned_sequence[start:start+4]
    ali_end_quad = aligned_sequence[end-4:end]

    # Confirmation display
    logging.debug(f"Section: {start_in} to {end_in}")
    logging.debug(f"In the aligned sequence: {start+1} to {end+1}")

    starter = "In the   raw   sequence: "
    logging.debug(f"{starter} {raw_start_quad} to {raw_end_quad}")

    starter = "In the aligned sequence: "
    logging.debug(f"{starter} {ali_start_quad} to {ali_end_quad}")

    # Return 1 based
    return(start+1, end)


#
# Function to calculate the similarity of part of a compared sequence. The
# similarity is the number of identical letters (denoted in the compared
# sequence by a dash) expressed as a percentage of the length of the part of
# the sequence being compared.
#
# Inputs
# - name of sequence being compared
#
# - start of the section being compared (first character is character 1)
# - None means 'the whole sequence'
#
# - end of the section being compared (first character is character 1
# - None means 'the whole sequence'
#
# Outputs
# - similarity, as a percentage
#
def similarity(name: str, aligned_start: int, aligned_end: int) -> float:

    similarity = None

    # If aligned_ are None, this means the whole aligned sequence
    if not aligned_start:
        aligned_start = 1
    if not aligned_end:
        aligned_end = data[name]['align_len']

    # Validate
    if aligned_start < 1 or aligned_start > data[name]['align_len']:
        logging.warning("aligned_start is illegal")
    elif aligned_end < 1 or aligned_end > data[name]['align_len']:
        logging.warning("aligned_end is illegal")
    elif aligned_start > aligned_end:
        logging.warning("aligned_start is after aligned_end")
    else:
        # Count the dashes
        section = data[name]['compared_sequence'][aligned_start-1:aligned_end]
        dash_count = section.count('-')

        # Calculate the similarity
        similarity = round(((100*dash_count) / len(section)), 2)

    return(similarity)


#
# Function to calculate the similarites for all sequences
#
# Inputs
# - sequences from 'data'
#
# Outputs
# - offset lookup list
#
def similarities() -> list:

    raw_sequence = None
    aligned_sequence = None

    # Find the raw and aligned sequences for the reference
    for name in data:
        if name == config['reference']['name']:
            raw_sequence = data[name]['raw_sequence']
            aligned_sequence = data[name]['aligned_sequence']

    # Build a list of offsets - first we need a list in which to store them
    offsets = []

    # Step through the raw sequence, checking the aligned sequence,
    # and recording offsets
    for offset in range(len(raw_sequence)):
        if aligned_sequence[offset] != '/':
            offsets.append(offset)
        else:
            offset += 1

    # Now find the similarities for each sequence
    logging.info("Calcuating similarities")

    for name in data:
        if name == config['reference']['name']:
            data[name]['rbd_similarity'] = 100.0
            data[name]['rbm_similarity'] = 100.0
            data[name]['full_similarity'] = 100.0
        else:
            # Find the start and end offsets
            rbd_start = config['reference']['rbd_start']
            rbd_end = config['reference']['rbd_end']
            rbm_start = config['reference']['rbm_start']
            rbm_end = config['reference']['rbm_end']

            aligned_start, aligned_end = align_off(name,
                                                   offsets,
                                                   rbd_start,
                                                   rbd_end,
                                                   raw_sequence)

            data[name]['rbd_similarity'] = similarity(name,
                                                      aligned_start,
                                                      aligned_end)

            aligned_start, aligned_end = align_off(name,
                                                   offsets,
                                                   rbm_start,
                                                   rbm_end,
                                                   raw_sequence)

            data[name]['rbm_similarity'] = similarity(name,
                                                      aligned_start,
                                                      aligned_end)

            data[name]['full_similarity'] = similarity(name, None, None)

    # Copy the offsets out for other functions
    return(offsets)


#
# Function to compare the sequences
#
# Inputs
# - sequences from 'data'
#
# Outputs
# - comparisons in 'data'
#
def compare_sequences():

    # First of all, load the reference
    reference = None

    for entry in data:
        if entry == config['reference']['name']:
            if reference:
                logging.warning("Ignoring a rogue reference")
            else:
                reference = data[entry]['aligned_sequence']

    # Check we do have a reference
    if not reference:
        logging.error("No reference found")
    else:
        # Step through all the non-reference sequences
        for entry in data:
            # Set the dash count to the same as the aligned sequence length
            # for the reference sequence
            if entry == config['reference']['name']:
                data[entry]['dash_count'] = data[entry]['align_len']
            else:
                sequence = data[entry]['aligned_sequence']

                # Step through each character in the reference sequence and
                # this sequence and compare
                comparison = ""

                for m, s in zip(reference, sequence):

                    # If they are the same, indicate this with a hyphen
                    if s == m:
                        comparison += "-"
                    else:
                        comparison += s

                # Update our data
                data[entry]['compared_sequence'] = comparison
                data[entry]['compare_len'] = len(comparison)
                data[entry]['dash_count'] = comparison.count('-')


#
# Function to find the longest friendly name
#
# Inputs
# - Friendly names from 'data'
#
# Outputs
# - Length
#
def find_longest_friendly_name() -> int:
    maxlen = 0
    for name in data:
        if len(data[name]['friendly_name']) > maxlen:
            maxlen = len(data[name]['friendly_name'])
    return(maxlen)


#
# Function to display the compared sequences
#
# Inputs
# - sequence information from 'data'
#
def display_information():

    maxlen = find_longest_friendly_name()

    # Header
    header_fields = ["Accession Identifier",
                     "Raw Sequence Length",
                     "Aligned Sequence Length",
                     "Similarity (%)",
                     "RBD Similarity (%)",
                     "RBM Similarity (%)"
                     ]

    # Display the friendly name first - adjusting the length of this field
    # dynamically to suit the user supplied names
    print("\n")
    print("Friendly Name\t".rjust(maxlen+2), end="")
    print('\t'.join(header_fields))

    # Each sequence
    for name in data:

        # Notice the friendly name field dynamically resizes
        fields = [f"{data[name]['friendly_name'].rjust(maxlen+2)}",
                  f"{name:>20}",
                  f"{data[name]['raw_len']:>19}",
                  f"{data[name]['align_len']:>23}",
                  f"{data[name]['full_similarity']:>14}",
                  f"{data[name]['rbd_similarity']:>18}",
                  f"{data[name]['rbm_similarity']:>18}"
                  ]

        print('\t'.join(fields))


#
# Function to create the indicator line. This line identifies where the
# receptor binding domain is using '!' characters. It also denotes where the
# receptor binding motif is using '?' characters.
#
# Inputs
# - offset - starting offset of the aligned sequence which is about to be
#            displayed
# - width - how many characters from the aligned sequence which is about to
#           be displayed
# - rbd_start - start of the receptor binding domain
# - rbm_start - start of the receptor binding motif
# - rbm_end - end of the receptor binding motif
# - rbd_end - end of the receptor binding domain
#
# Outputs
# - Entire indicator line
#
def make_indicator_line(offset: int,
                        width: int,
                        rbd_start: int,
                        rbm_start: int,
                        rbm_end: int,
                        rbd_end: int):

    # Define a list to represent the line
    line = [' '] * width

    for i in range(width):
        if offset+i >= rbd_start and offset+i < rbd_end:
            line[i] = '!'
        if offset+i >= rbm_start and offset+i < rbm_end:
            line[i] = '?'

    return(''.join(line))


#
# Function to create the label line which identifies the
# receptor binding domain and receptor binding motif
#
# Inputs
# - offset (0 based, in raw reference sequence)
# - width - number of characters being displayed
# - offsets - offsets between raw and aligned sequence
#
# Outputs
# - Label line for display
#
def label_line(offset: int, width: int, offsets: list) -> str:

    # Find the receptor binding offsets in aligned sequence, 0 based
    rbd_start = offsets[int(config['reference']['rbd_start'])] - 1
    rbm_start = offsets[int(config['reference']['rbm_start'])] - 1
    rbm_end = offsets[int(config['reference']['rbm_end'])] - 1
    rbd_end = offsets[int(config['reference']['rbd_end'])] - 1

    # Making an assumption here that the rbm is within the rbd
    if offset+width < rbd_start or offset > rbd_end:
        line = ""
    else:
        line = make_indicator_line(offset,
                                   width,
                                   rbd_start,
                                   rbm_start,
                                   rbm_end,
                                   rbd_end)

    return(line)


#
# Function to display the compared sequences
#
# Inputs
# - start (1 based, in raw reference sequence)
# - end (1 based, in raw reference sequence)
# - length of raw sequence to display
# - width of screen display in characters
# - offsets - offsets between raw and aligned sequence
#   aligned sequence offset = offsets[raw sequence offset]
#
# Outputs
# - Compared sequences, to stdout
#
def display_sequence_display(start: int,
                             end: int,
                             length: int,
                             width: int,
                             offsets: list,
                             label: bool):

    maxlen = find_longest_friendly_name()

    # Define starting offset through the sequence
    offset = offsets[start-1]

    if (end-1) < len(offsets):
        end = offsets[end-1]

    # Record the starting position
    for name in data:
        data[name]['position'] = start

    # Step through the entire aligned sequence
    while(offset < end - 1):

        # Put a newline between each chunk
        print()

        # Step through each name
        for name in data:

            # Calculate the actual displayed width
            if (offset + width) < end:
                display_width = width
            else:
                display_width = end - offset

            # ###############################################################
            # DISPLAY THE LABEL LINE
            #
            if label and name == config['reference']['name']:
                line = label_line(offset, display_width, offsets)

                # maxlen+2 is what we use to align the friendly name
                # 1 is a space
                # 6 is the number of characters used for the position
                # 1 is another space
                print(" ".rjust(maxlen+2+1+6+1) + line)
            #
            #
            # ###############################################################

            # ###############################################################
            # FETCH THE SEQUENCE TO BE DISPLAYED
            #
            # Aligned sequence for the reference
            if name == config['reference']['name']:
                sequence = data[name]['aligned_sequence']

            # Compared sequence for the others
            else:
                sequence = data[name]['compared_sequence']

            # Slice off just the part we need
            sequence = sequence[offset:offset+display_width]

            #
            #
            # ###############################################################

            # ###############################################################
            # CALCULATE START AND END POSITION
            #
            # Measure the sequence
            displayed = len(sequence)

            # Fetch the aligned_sequence - we always need this as this is
            # used to calculate the position
            aligned_sequence = data[name]['aligned_sequence']
            aligned_sequence = aligned_sequence[offset:offset+display_width]

            # Count the slashes in the aligned sequence
            slashes = aligned_sequence.count('/')

            # Calculate how many characters displayed
            c_displayed = displayed - slashes

            # Set the start and end position, ready for display
            start_position = data[name]['position']
            end_position = data[name]['position'] + c_displayed - 1

            # Update the position for the next time
            data[name]['position'] = end_position + 1
            #
            #
            # ###############################################################

            # Display the line, with positions
            fname = data[name]['friendly_name'].rjust(maxlen+2)
            print(f"{fname} {start_position:>6} {sequence} {end_position}")

        # Increment the offset
        offset += width


#
# Function to handle the display of the sequences
#
# Input
# - Display width
# = Output type required
# - List of offsets of the raw seauence in the aligned sequence
#
# Output
# - Display to screen
#
def display_sequence(lines: int, width: int, output: int, offsets: list):

    # Define required start and end of the sequence
    # Calculate the number of characters to display
    if output == 'rbd':
        start = int(config['reference']['rbd_start'])
        end = int(config['reference']['rbd_end'])
        length = end - start + 1
        label = False
    elif output == 'rbm':
        start = int(config['reference']['rbm_start'])
        end = int(config['reference']['rbm_end'])
        length = end - start + 1
        label = False
    else:
        start = 1
        end = data[config['reference']['name']]['align_len']
        length = end
        label = True

    # If lines is set, calculate the width accordingly
    if lines:
        width = int(length / lines)

    # Display
    display_sequence_display(start, end, length, width, offsets, label)


#
# Function to load the config file, creating a new one if it does not exist
#
# Input
# - Config from external .ini file
#
# Output
# - Config
#
def load_config() -> dict:

    # If the file doesn't exist, create it
    if not os.path.exists(config_filename):
        logging.info(f"Creating a new config file in {config_filename}")
        fh = open(config_filename, "w")
        fh.close()

    # Flag to record if the config has been altered
    altered = False

    # Load config file
    conf = configparser.ConfigParser()
    conf.read(config_filename)

    # Create a new entry for a missing email address
    if 'email' not in conf.sections():
        print("An email address is required to identify your use of Entrez")
        conf['email'] = {}
        conf['email']['address'] = input("Enter email address: ")
        altered = True

    # Create default entries for any other missing items
    if 'reference' not in conf.sections():
        conf['reference'] = {}
        conf['reference']['name'] = "YP_009724390.1"
        conf['reference']['rbd_start'] = "319"
        conf['reference']['rbm_start'] = "438"
        conf['reference']['rbm_end'] = "509"
        conf['reference']['rbd_end'] = "542"
        altered = True

    # Update the config file if any changes have been made
    if altered:
        with open(config_filename, "w") as fh:
            conf.write(fh)

    return(conf)


#
# Function to load the command line inputs
#
#
# Output
# - parsed arguments
#
def load_commandline():
    parser = argparse.ArgumentParser(description='Virus comparator')

    # Width and Length - neither are required, but cannot specify both
    group = parser.add_mutually_exclusive_group(required=False)

    helpstr = 'Width of character display in characters (100)'
    group.add_argument('-w', '--width', type=int, default=100, help=helpstr)

    helpstr = 'Number of lines of display'
    group.add_argument('-l', '--lines', type=int, help=helpstr)

    # Ungrouped parameters
    helpstr = 'File describing viruses to compare'
    parser.add_argument('input', type=str, help=helpstr)

    helpstr = "Choice of output (default is full)"
    parser.add_argument('--out',
                        default='full',
                        const='full',
                        nargs='?',
                        choices=('full', 'rbd', 'rbm'),
                        help=helpstr)

    helpstr = 'Display version and exit'
    out = f"This is\n shirley version {VERSION}"
    parser.add_argument('-V', '--version', action='version', help=helpstr,
                        version=out)

    helpstr = 'Verbose logging (use twice for greater effect)'
    parser.add_argument('-v', '--verbose', action='count', help=helpstr,
                        default=0)

    args = parser.parse_args()

    return(args)


# ########################################################################## #
# MAIN #
# ########################################################################## #

if __name__ == '__main__':

    # Load command line
    args = load_commandline()

    # Start the logger
    if args.verbose == 1:
        level = logging.INFO
    elif args.verbose >= 2:
        level = logging.DEBUG
    else:
        level = logging.WARNING

    logging.basicConfig(level=level)

    # Define the config filename
    config_filename = "shirley.ini"

    # Load the config from the config file
    config = load_config()

    # Define data structure for sequences
    #
    # Keys are the codename of the virus
    # Value is another dictionary with keys - see new_thing() for structure:
    #
    data = {}

    # Determine which sequences we are looking at
    determine_sequences(args.input)

    # Fetch the sequence data
    fetch_sequences(config['email']['address'])

    # Align the sequences
    align_sequences()

    # Compare the sequences
    compare_sequences()

    # Calculate similarities
    offsets = similarities()

    # Display information block
    display_information()

    # Display the sequence
    display_sequence(args.lines, args.width, args.out, offsets)

    # Dump structure if required
    if args.verbose >= 2:
        pprint(data, stream=sys.stderr)
